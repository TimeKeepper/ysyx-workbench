package riscv_cpu

import chisel3._
import chisel3.util._

import chisel3.util.BitPat

// total instruction num: 35

object Instructions {
  // Loads
  def LB     = "b?????????????????000?????0000011"
  def LH     = "b?????????????????001?????0000011"
  def LW     = "b?????????????????010?????0000011"
  def LBU    = "b?????????????????100?????0000011"
  def LHU    = "b?????????????????101?????0000011"
  // Stores
  def SB     = "b?????????????????000?????0100011"
  def SH     = "b?????????????????001?????0100011"
  def SW     = "b?????????????????010?????0100011"
  // Shifts
  def SLL    = "b0000000??????????001?????0110011"
  def SLLI   = "b0000000??????????001?????0010011"
  def SRL    = "b0000000??????????101?????0110011"
  def SRLI   = "b0000000??????????101?????0010011"
  def SRA    = "b0100000??????????101?????0110011"
  def SRAI   = "b0100000??????????101?????0010011"
  // Arithmetic
  def ADD    = "b0000000??????????000?????0110011"
  def ADDI   = "b?????????????????000?????0010011"
  def SUB    = "b0100000??????????000?????0110011"
  def LUI    = "b?????????????????????????0110111"
  def AUIPC  = "b?????????????????????????0010111"
  // Logical
  def XOR    = "b0000000??????????100?????0110011"
  def XORI   = "b?????????????????100?????0010011"
  def OR     = "b0000000??????????110?????0110011"
  def ORI    = "b?????????????????110?????0010011"
  def AND    = "b0000000??????????111?????0110011"
  def ANDI   = "b?????????????????111?????0010011"
  // Compare
  def SLT    = "b0000000??????????010?????0110011"
  def SLTI   = "b?????????????????010?????0010011"
  def SLTU   = "b0000000??????????011?????0110011"
  def SLTIU  = "b?????????????????011?????0010011"
  // Branches
  def BEQ    = "b?????????????????000?????1100011"
  def BNE    = "b?????????????????001?????1100011"
  def BLT    = "b?????????????????100?????1100011"
  def BGE    = "b?????????????????101?????1100011"
  def BLTU   = "b?????????????????110?????1100011"
  def BGEU   = "b?????????????????111?????1100011"
  // Jump & Link
  def JAL    = "b?????????????????????????1101111"
  def JALR   = "b?????????????????000?????1100111"
  // Synch
  def FENCE  = "b0000????????00000000000000001111"
  def FENCEI = "b00000000000000000001000000001111"
  // CSR Access
  def CSRRW  = "b?????????????????001?????1110011"
  def CSRRS  = "b?????????????????010?????1110011"
  def CSRRC  = "b?????????????????011?????1110011"
  def CSRRWI = "b?????????????????101?????1110011"
  def CSRRSI = "b?????????????????110?????1110011"
  def CSRRCI = "b?????????????????111?????1110011"
  // Change Level
  def ECALL  = "b00000000000000000000000001110011"
  def EBREAK = "b00000000000100000000000001110011"
  def ERET   = "b00010000000000000000000001110011"
  def WFI    = "b00010000001000000000000001110011"

  def MRET   = "b00110000001000000000000001110011"
  def NOP    = "b00000000000000000000000000010011"
}

object signal_value {
  def Y = true.B
  def N = false.B

  // ExtOp
  def Imm_Type   = UInt(3.W)
  def Imm_I       = 0.U(3.W) //I型指令
  def Imm_U       = 1.U(3.W) //U型指令
  def Imm_S       = 2.U(3.W) //S型指令
  def Imm_B       = 3.U(3.W) //B型指令
  def Imm_J       = 4.U(3.W) //J型指令

  // Branch
  def Bran_Type = UInt(4.W)
  def Bran_NJmp = 0.U(4.W) //非跳转
  def Bran_Jmp  = 1.U(4.W) //无条件跳转
  def Bran_Jmpr = 2.U(4.W) //寄存器基址跳转
  def Bran_Jeq  = 4.U(4.W) //相等跳转
  def Bran_Jne  = 5.U(4.W) //不相等跳转
  def Bran_Jlt  = 6.U(4.W) //小于跳转
  def Bran_Jge  = 7.U(4.W) //大于等于跳转
  def Bran_Jcsr = 8.U(4.W) //CSR跳转
  def Bran_NoC  = 9.U(4.W) //不要改变

  // Branch sub signal
  def PCAsrc_Type = UInt(2.W)
  def PCAsrc_Imm  = 0.U(2.W) //立即数
  def PCAsrc_0    = 1.U(2.W) //立即数0
  def PCAsrc_4    = 2.U(2.W) //立即数4
  def PCAsrc_csr  = 3.U(2.W) //CSR寄存器

  def PCBsrc_Type = UInt(2.W)
  def PCBsrc_gpr  = 0.U(2.W) //GPR寄存器
  def PCBsrc_pc   = 1.U(2.W) //PC寄存器
  def PCBsrc_0    = 2.U(2.W) //立即数0

  // MemOp
  def MemOp_Type = UInt(3.W)
  def MemOp_1BU      = 0.U(3.W) //1字节无符号
  def MemOp_1BS      = 1.U(3.W) //1字节有符号
  def MemOp_2BU      = 2.U(3.W) //2字节无符号
  def MemOp_2BS      = 3.U(3.W) //2字节有符号
  def MemOp_4BU      = 4.U(3.W) //4字节无符号

  // ALUAsrc
  def ALUAsrc_Type = UInt(2.W)
  def ALUAsrc_RS1        = 0.U(2.W) //寄存器资源1
  def ALUAsrc_PC         = 1.U(2.W) //PC寄存器
  def ALUAsrc_CSR        = 2.U(2.W) //CSR寄存器

  // ALUBSrc
  def ALUBSrc_Type = UInt(2.W)
  def ALUBSrc_RS2        = 0.U(2.W) //寄存器资源2
  def ALUBSrc_IMM        = 1.U(2.W) //立即数
  def ALUBSrc_4          = 2.U(2.W) //立即数4
  def ALUBSrc_RS1        = 3.U(2.W) //寄存器资源1

  // ALUctr
  def ALUctr_Type = UInt(4.W)
  def ALUctr_ADD     = 0.U(4.W) //加法
  def ALUctr_SUB     = 1.U(4.W) //减法
  def ALUctr_Less_U  = 2.U(4.W) //小于无符号
  def ALUctr_Less_S  = 3.U(4.W) //小于
  def ALUctr_A       = 4.U(4.W) //输出A
  def ALUctr_B       = 5.U(4.W) //输出B
  def ALUctr_SLL     = 6.U(4.W) //逻辑左移
  def ALUctr_SRL     = 7.U(4.W) //逻辑右移
  def ALUctr_SRA     = 8.U(4.W) //算术右移
  def ALUctr_XOR     = 9.U(4.W) //异或
  def ALUctr_OR      = 10.U(4.W) //或
  def ALUctr_AND     = 11.U(4.W) //与

  // csr_ctr
  def CSR_Type = UInt(2.W)
  def CSR_N    = 0.U(2.W) // 非csr读写指令
  def CSR_R1W0 = 1.U(2.W) // 不读写一， 目前只有 mret 符合
  def CSR_R1W1 = 2.U(2.W) // 读写一
  def CSR_R1W2 = 3.U(2.W) // 读一写二， 目前只有 ecall 符合
}

object bus_state {
  val s_wait_valid :: s_wait_ready :: s_busy :: s_pipeline :: Nil = Enum(4)
}
